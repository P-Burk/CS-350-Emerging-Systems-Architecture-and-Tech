# CS-350-Emerging-Systems-Architecture-and-Tech

## [Video recording of final project](https://youtu.be/mvEC0YF2eJ4)

## • Summarize the project and what problem it was solving.
The goal of the project was to make a smart thermostat prototype. We were given some functions, features, and the time intervals (periods) that they should occur in. The end goal wasn’t a full-fledged product, but more of a proof of concept for a company looking to expand their business into an adjacent space.

## • What did you do particularly well?
I felt that I tackled creating state machines well. This was a new concept to me and very confusing at first. I had never considered using switch statements to handle the different states of an entity and I know some fellow students had a lot of issues with it in our assignments. Once I created my first state machine during week 3, I felt that I was able to easily create effective and logical state machines in later assignments, including our final project.

## • Where could you improve?
One area I could improve on is making my code a bit more modular. I wanted to use a structure in the final project to lay out the attributes of a task. Later (optional) sections in our course material covered this and I tried to implement it per said material, but I couldn’t get it to work. I know this would make my code a bit more organized and more easily scalable. I feel that given a few more days I could implement a more structured way of defining and declaring tasks.

## •	What tools and/or resources are you adding to your support network?
I’ll be adding knowledge of more basic programming functions to my support network. I had never messed with hexadecimal, bit shifting, and similar programing concepts/functions before this class. 

## • What skills from this project will be particularly transferable to other projects and/or course work?
I think that the knowledge of state machines and the ability to create them is a skill that I can use in other projects and/or course work. I think that before, I was already using a rudimentary version of state machines in some projects, but this course taught us a more structured way of mapping them out and building them. This is something I can see being useful for projects that require a bunch of “moving parts” that make up an overall system.

## • How did you make this project maintainable, readable, and adaptable?
I made this project maintainable, readable, and adaptable by using flags that aren’t specific to any single state machine. This makes it adaptable in that other parts of the code can use these flags to trigger their own actions. I made my code readable by breaking up each peripheral into its own section and commenting my code liberally.
